#include <libmfwtimer.h>
#include "m200.h"
#include "hal.h"
#include "nbfi.h"
#include "nbfi_config.h"
#include <time.h>
//uint32_t    M200_add = 0xedc14;

struct wtimer_desc __xdata m200_regular_desc;
struct wtimer_desc __xdata m200_active_desc;
struct wtimer_desc __xdata m200_fastdl_desc;
struct wtimer_desc __xdata m200_sinchro_desc;
struct wtimer_desc __xdata m200_radiotest_desc;
struct wtimer_desc __xdata m200_write_tarif_desc;

void SendRegular(struct wtimer_desc __xdata *desc);
void ResetActive(struct wtimer_desc __xdata *desc);
void ResetFastDl(struct wtimer_desc __xdata *desc);
void TimeSinchro(struct wtimer_desc __xdata *desc);
void RadioTest(struct wtimer_desc __xdata *desc);

bool sw_free = 1;
struct tm time_st;
uint32_t __xdata LastTime;
uint32_t __xdata LastHourTime;
uint32_t __xdata LastDayTime;
uint32_t __xdata LastWeekTime;
uint32_t __xdata LastMonthTime;


uint32_t __xdata dltime;

uint8_t __xdata tmpbuf[64];
uint8_t __xdata lasthourbuf[30];
uint8_t __xdata lastdaybuf[30];
uint8_t __xdata lastweekbuf[30];
uint8_t __xdata lastmonthbuf[30];
uint8_t __xdata certaindaybuf[30];
uint8_t __xdata certaindaybuf_aux[30];
uint8_t __xdata m200_comm_number = 0;

uint8_t serial_is_changed = 0;

uint8_t regular_state = 0;
uint8_t sinchro_state = 0;
uint8_t write_tarif_state = 0;

TARIF_ZONE * tarif_mode;

uint32_t regular_counter = 1;
uint32_t regular_counter_aux = 1;
uint8_t write_tarif_try_num;

uint8_t display_mode = 0;
TARIF_ZONE onetarif[] =
{
    {T1, 0, 0},
    {END, 0, 0}
};

/*TARIF_ZONE twotarifs[] =
{
    {T1, 7, 0},
    {T2, 23, 0},
    {END, 0, 0}
};

TARIF_ZONE threetarifs[] =
{
    {T1, 7, 0},
    {T3, 10, 0},
    {T1, 17, 0},
    {T3, 21, 0},
    {T2, 23, 0},
    {END, 0, 0}
};*/

__reentrant uint16_t bcd2dec_r(uint16_t bcd)
{
    return bcd ? (bcd2dec_r(bcd>>4)*10) + (bcd & 0x0f) : 0;
}

uint8_t dec2bcd(uint8_t n)
{
 return (n / 10 * 16 +  n % 10);
}

void M200_Init()
{
    M200_ReadSettings();
    ScheduleTask(&m200_regular_desc, &SendRegular, RELATIVE, SECONDS(10));
    ScheduleTask(&m200_sinchro_desc, &TimeSinchro, RELATIVE, SECONDS(5));
}

void M200_Receive_Success()
{
    if(serial_is_changed) serial_is_changed = 2;

    if(m200_comm_number == m200_rxbuf.cmd)
    {
        m200_comm_number = 0;
        switch(m200_rxbuf.cmd)
        {
            case 0x02:
                M200_Send_Event(0x09, dltime, 0);
            break;
            //case 0x0A:
            //    M200_Send_Event(0x11, 0, 0);
            //break;
            default:
                tmpbuf[0] = 210;
                for(uint8_t i = 0; i != m200_rxbuf.len - 6; i++) tmpbuf[i+1] = m200_rxbuf.payload[4 + i];
                NBFi_Send(tmpbuf, m200_rxbuf.len - 5);
            break;
        }
        return;
    }
    switch(m200_rxbuf.cmd)
    {
    case 0x0A:
        if(write_tarif_state == 1)
        {
            write_tarif_state = 100; write_tarif_try_num = 0;
            ScheduleTask(&m200_write_tarif_desc, &M200_Write_Tarif_Main, RELATIVE, MILLISECONDS(5));
        }
        break;

    case 0x2A:
        if(write_tarif_state == 100)
        {
            display_mode = m200_rxbuf.payload[5];
            write_tarif_state = 101; write_tarif_try_num = 0;
            ScheduleTask(&m200_write_tarif_desc, &M200_Write_Tarif_Main, RELATIVE, MILLISECONDS(5));
        }
        break;
    case 0x09:
        if(write_tarif_state == 101)
        {
            write_tarif_state = 2; write_tarif_try_num = 0;
            ScheduleTask(&m200_write_tarif_desc, &M200_Write_Tarif_Main, RELATIVE, MILLISECONDS(5));
        }
        break;


    case 0x11:
        if(write_tarif_state >= 2)
        {
                write_tarif_state++; write_tarif_try_num = 0;
                ScheduleTask(&m200_write_tarif_desc, &M200_Write_Tarif_Main, RELATIVE, MILLISECONDS(5));
        }
        break;
    case 0x21:
        time_st.tm_wday = bcd2dec_r(m200_rxbuf.payload[5]);
        time_st.tm_hour = bcd2dec_r(m200_rxbuf.payload[6]);
        time_st.tm_min = bcd2dec_r(m200_rxbuf.payload[7]);
        time_st.tm_sec = bcd2dec_r(m200_rxbuf.payload[8]);
        time_st.tm_mday = bcd2dec_r(m200_rxbuf.payload[9]);
        time_st.tm_mon = bcd2dec_r(m200_rxbuf.payload[10]) - 1;
        time_st.tm_year = bcd2dec_r(m200_rxbuf.payload[11]) + 100;
        LastTime = mktime(&time_st);
        if(regular_state == 1) regular_state = 2;
        if(sinchro_state == 1) sinchro_state = 2;
        break;
    case 0x27:
        if(regular_state == 3)
        {
            regular_state = 0;
            M200_Report_Regular(0);
            ScheduleTask(&m200_regular_desc, &SendRegular, RELATIVE, SECONDS(10));
        }
        if(sinchro_state == 3)
        {
            sinchro_state = 0;
            M200_Stamp();
            ScheduleTask(&m200_sinchro_desc, &TimeSinchro, RELATIVE, (3600-(LastTime%(3600)))*SECONDS(1));
        }
        break;
    default:
        /*tmpbuf[0] = 210;
        for(uint8_t i = 0; i != m200_rxbuf.len - 6; i++) tmpbuf[i+1] = m200_rxbuf.payload[4 + i];
        NBFi_Send(tmpbuf, m200_rxbuf.len - 5);*/
        break;
    }
}

void M200_Receive_Timeout()
{
    if(m200_comm_number)
    {
        if(m200_comm_number == 0x02) m200_comm_number = 245;
        //else if(m200_comm_number == 0x0A) m200_comm_number = 202;
        M200_Send_Event(200, 0, m200_comm_number*256);
        m200_comm_number = 0;
    }
}

void SendRegular(struct wtimer_desc __xdata *desc)
{
    static uint8_t try_num;
    switch(regular_state)
    {
    case 0: //start
        if(!(regular_counter%m200_settings.regular_period))
        {
            switch(m200_settings.read_mode)
            {
                case ATENDOFHOUR:
                    if(lasthourbuf[0] == 0x31) NBFi_Send(lasthourbuf, 29);
                    else M200_Send_Event(200, 0, 0x31*256);
                    lasthourbuf[0] = 0;
                    break;
                case ATENDOFDAY:
                    if(lastdaybuf[0] == 0x31)  NBFi_Send(lastdaybuf, 29);
                    else M200_Send_Event(200, 0, 0x31*256);
                    lastdaybuf[0] = 0;
                    break;
                case ATENDOFWEEK:
                    if(lastweekbuf[0] == 0x31) NBFi_Send(lastweekbuf, 29);
                    else M200_Send_Event(200, 0, 0x31*256);
                    //lastweekbuf[0] = 0;
                    break;
                case ATENDOFMONTH:
                    if(lastmonthbuf[0] == 0x31) NBFi_Send(lastmonthbuf, 29);
                    else M200_Send_Event(200, 0, 0x31*256);
                    //lastmonthbuf[0] = 0;
                    break;
                default:
                    if((m200_settings.read_mode&0x80) == ATCERTAINDAY)
                    {
                        if(certaindaybuf[0] == 0x31) NBFi_Send(certaindaybuf, 29);
                        else M200_Send_Event(200, 0, 0x31*256);
                        certaindaybuf[0] = 0;
                    }

                    break;
            }
        }
        if(!(regular_counter_aux++%m200_settings.regular_period_aux))
        {
            switch(m200_settings.read_mode_aux)
            {
                case ATENDOFDAY:
                    if(lastdaybuf[0] == 0x31)  NBFi_Send(lastdaybuf, 29);
                    else M200_Send_Event(200, 0, 0x31*256);
                    //lastdaybuf[0] = 0;
                    break;
                case ATENDOFWEEK:
                    if(lastweekbuf[0] == 0x31) NBFi_Send(lastweekbuf, 29);
                    else M200_Send_Event(200, 0, 0x31*256);
                    //lastweekbuf[0] = 0;
                    break;
                case ATENDOFMONTH:
                    if(lastmonthbuf[0] == 0x31) NBFi_Send(lastmonthbuf, 29);
                    else M200_Send_Event(200, 0, 0x31*256);
                    //lastmonthbuf[0] = 0;
                    break;
                default:
                    if((m200_settings.read_mode_aux&0x80) == ATCERTAINDAY)
                    {
                        if(certaindaybuf_aux[0] == 0x31) NBFi_Send(certaindaybuf_aux, 29);
                        else M200_Send_Event(200, 0, 0x31*256);
                        certaindaybuf_aux[0] = 0;
                    }

                    break;
            }
        }

        if((regular_counter++%m200_settings.regular_period) || (m200_settings.read_mode != ATONCE)) break;
    case 5:
        if(sinchro_state||((write_tarif_state > 0)&&(write_tarif_state < 99)) )
        {
            ScheduleTask(&m200_regular_desc, &SendRegular, RELATIVE, SECONDS(1));
            return;
        }
        regular_state = 1;
        try_num = 0;
    case 1:
        if(++try_num <= 3) M200_Send(0x21, 0, 0);
        else
        {
            M200_Send_Event(200, 0, 0x31*256);
            regular_state = 0;
            break;
        }
        ScheduleTask(&m200_regular_desc, &SendRegular, RELATIVE, SECONDS(1));
        return;
    case 2:
        try_num = 0;
        regular_state = 3;
    case 3:
        if(++try_num < 3) M200_Send(0x27, 0, 0);
        else
        {
            M200_Send_Event(200, 0, 0x31*256);
            regular_state = 0;
            break;
        }
        ScheduleTask(&m200_regular_desc, &SendRegular, RELATIVE, SECONDS(1));
        return;
    case 4:
        break;
    }

    if(NBFi_Is_Mode_Normal())
    {
        static uint8_t tries = 0;
        if(serial_is_changed == 2)
        {
            serial_is_changed = 0;
            tmpbuf[0] = 0xEE;
            tmpbuf[1] = 0x01;
            uint32_t serial = m200_settings.rs_add;
            uint32_t k = 100000000;

            for(uint8_t i = 2; i != 7; i++ )
            {
               tmpbuf[i] =  dec2bcd(serial/k);
               serial %= k;
               k /= 100;
            }
            NBFi_Send(tmpbuf, 7);
        }
        else if(serial_is_changed == 1)
        {
            if(++tries > 3)
            {
                    M200_Send_Event(200, 0, 256*0x20);
                    serial_is_changed = 0;
            }
            else M200_Send(0x20, 0, 0);
        }
        else  tries = 0;

    }
    ScheduleTask(&m200_regular_desc, &SendRegular, RELATIVE, SECONDS(10));
}


void TimeSinchro(struct wtimer_desc __xdata *desc)
{
    static uint8_t try_num;

    switch(sinchro_state)
    {
    case 0:
        if(regular_state||((write_tarif_state > 0)&&(write_tarif_state < 99)))
        {
            ScheduleTask(&m200_sinchro_desc, &TimeSinchro, RELATIVE, SECONDS(10));
            return;
        }
        sinchro_state = 1;
        try_num = 0;
    case 1:

        if(++try_num <= 3) M200_Send(0x21, 0, 0);
        else
        {
            sinchro_state = 0;
            break;
        }
        ScheduleTask(&m200_sinchro_desc, &TimeSinchro, RELATIVE, SECONDS(1));
        return;
    case 2:
        try_num = 0;
        sinchro_state = 3;
    case 3:
        if(++try_num < 3) M200_Send(0x27, 0, 0);
        else
        {
            sinchro_state = 0;
            break;
        }
        ScheduleTask(&m200_sinchro_desc, &TimeSinchro, RELATIVE, SECONDS(1));
        return;

    }
    ScheduleTask(&m200_sinchro_desc, &TimeSinchro, RELATIVE, SECONDS(3600));
}


long int  _timezone;
long int  _dstbias;


bool M200_isCanSleep()
{
    return rs_free&sw_free;
}

void M200_Report_Regular(uint8_t __xdata *buf)
{
    uint8_t index = 1;
    uint8_t __xdata *tbuf;
    if(buf) tbuf = buf;
    else tbuf = tmpbuf;
    tbuf[0] = 0x31;
    PARAM_IDENTIFIER param;
    param.timestamp_flag = 1;
    param.obis_A = 0;
    param.obis_B = 0;
    param.obis_C = 1;
    param.obis_D = 1;
    for(uint8_t i = 0; i!=4; i++)
    {
        param.obis_E = i+1;
        param.timestamp_flag = (i==0);
        *((uint16_t*)(&tbuf[index])) = *((uint16_t*)(&param));
        index += 2;
        if(!i)
        {
            tbuf[index++] = (LastTime >> 24) & 0xFF;
            tbuf[index++] = (LastTime >> 16) & 0xFF;
            tbuf[index++] = (LastTime >> 8) & 0xFF;
            tbuf[index++] = (LastTime >> 0) & 0xFF;
        }

        uint32_t val = 0;
        for(uint8_t k = 0; k!=4; k++)
        {
            val += bcd2dec_r(m200_rxbuf.payload[5 + i*4 + k]);
            if(k < 3) val *= 100;
        }
        val*=10;
        tbuf[index++] = (val >> 24) & 0xFF;
        tbuf[index++] = (val >> 16) & 0xFF;
        tbuf[index++] = (val >> 8) & 0xFF;
        tbuf[index++] = (val >> 0) & 0xFF;
    }
    if(buf == 0) NBFi_Send(tmpbuf, index);

}


void M200_Stamp()
{
    if(LastHourTime/3600 != LastTime/3600)
    {
        M200_Report_Regular(lasthourbuf);
        LastHourTime = LastTime;
        if(time_st.tm_hour == 0)
        {
            M200_Report_Regular(lastdaybuf);
            LastDayTime = LastTime;

            if(m200_settings.read_mode>=0x80)
            {
                if(time_st.tm_mday == (((uint8_t)m200_settings.read_mode)&0x7f))
                {
                    M200_Report_Regular(certaindaybuf);
                    if((m200_settings.regular_period - (regular_counter%m200_settings.regular_period)) >  (360*20) )
                    {
                        regular_counter = m200_settings.regular_period - (regular_counter%(360*20));
                    }
                }
            }

            if(m200_settings.read_mode_aux >= 0x80)
            {
                if(time_st.tm_mday == (((uint8_t)(m200_settings.read_mode_aux))&0x7f))
                {
                    M200_Report_Regular(certaindaybuf_aux);
                    if((m200_settings.regular_period_aux - (regular_counter_aux%m200_settings.regular_period_aux)) >  (360*20) )
                    {
                        regular_counter_aux = m200_settings.regular_period_aux - (regular_counter_aux%(360*20));
                    }
                }
            }

            if(time_st.tm_wday == 1)
            {
                M200_Report_Regular(lastweekbuf);
                LastWeekTime = LastTime;

                if((m200_settings.regular_period >= 60480)&&(m200_settings.regular_period <= 241920))
                {
                    if((m200_settings.regular_period - (regular_counter%m200_settings.regular_period)) >  (360*20) )
                    {
                        regular_counter = m200_settings.regular_period - (regular_counter%(360*20));
                    }
                }
                if((m200_settings.regular_period_aux >= 60480)&&(m200_settings.regular_period_aux <= 241920))
                {
                    if((m200_settings.regular_period_aux - (regular_counter_aux%m200_settings.regular_period_aux)) >  (360*20) )
                    {
                        regular_counter_aux = m200_settings.regular_period_aux - (regular_counter_aux%(360*20));
                    }
                }

            }else lastweekbuf[0] = 0;

            if(time_st.tm_mday == 1)
            {
                M200_Report_Regular(lastmonthbuf);
                LastMonthTime = LastTime;
                if(m200_settings.regular_period >= 267840)
                {
                    if((m200_settings.regular_period - (regular_counter%m200_settings.regular_period)) >  (360*24*5) )
                    {
                        regular_counter = m200_settings.regular_period - (regular_counter%(360*24*5));
                    }
                }
                if(m200_settings.regular_period_aux >= 267840)
                {
                    if((m200_settings.regular_period_aux - (regular_counter_aux%m200_settings.regular_period_aux)) >  (360*24*5) )
                    {
                        regular_counter_aux = m200_settings.regular_period_aux - (regular_counter_aux%(360*24*5));
                    }
                }
            }else if(time_st.tm_mday > 5) lastmonthbuf[0] = 0;

        }//else lastdaybuf[0] = 0;
    }

}

void bigendian_cpy(uint8_t __xdata* from, uint8_t __xdata* to, uint8_t len);

void M200_RX_Callback(uint8_t __generic* data, uint16_t length)
{
    uint8_t i;

    if(CheckTask(&m200_fastdl_desc))
    {
        ScheduleTask(&m200_fastdl_desc, &ResetFastDl, RELATIVE, SECONDS(60*2));
    }

    switch(data[0])
    {
    case 200:   //set add
        if(length == 5)
        {
            bigendian_cpy((uint8_t __xdata*)&data[1],(uint8_t __xdata*)&m200_settings.rs_add, 4);
            serial_is_changed = 1;

            M200_WriteSettings();
        }
        else if(length == 1)
        {
            tmpbuf[0] = 200;
            bigendian_cpy( (uint8_t __xdata*)&m200_settings.rs_add, (uint8_t __xdata*)(&tmpbuf[1]), 4);
            NBFi_Send(tmpbuf, 5);
        }
        break;
    case 201:   //set add
        if(length == 11)
        {
            bigendian_cpy( (uint8_t __xdata*)&data[1], (uint8_t __xdata*)&m200_settings.regular_period, 4);
            m200_settings.read_mode = data[5];
            bigendian_cpy( (uint8_t __xdata*)&data[6], (uint8_t __xdata*)&m200_settings.regular_period_aux, 4);
            m200_settings.read_mode_aux = data[10];
            M200_WriteSettings();
        }
        else if(length == 1)
        {
            tmpbuf[0] = 201;
            bigendian_cpy((uint8_t __xdata*)&m200_settings.regular_period, (uint8_t __xdata*)&tmpbuf[1], 4);
            tmpbuf[5] = m200_settings.read_mode;
            bigendian_cpy((uint8_t __xdata*)&m200_settings.regular_period_aux, (uint8_t __xdata*)&tmpbuf[6], 4);
            tmpbuf[10] = m200_settings.read_mode_aux;
            NBFi_Send(tmpbuf, 11);
        }
        break;
    case 202:
        if(length == 2)
        {
            if((data[1] >= 1) && (data[1] <= 3))
            {
                switch(data[1])
                {
                    case 1: tarif_mode = onetarif; m200_settings.t_mode = 1; break;
                    case 2: tarif_mode = m200_settings.twotarifs; m200_settings.t_mode = 2; break;
                    case 3: tarif_mode = m200_settings.threetarifs; m200_settings.t_mode = 3; break;
                    return;
                }
                M200_Write_Tarif_Main(0);
                //m200_comm_number = 0x0A;
                //M200_Send(0x0A, &data[1], 1);
            }
        }
        else if(length == 1)
        {
                tmpbuf[0] = 202;
                tmpbuf[1] = m200_settings.t_mode;
                NBFi_Send(tmpbuf, 2);
        }
        break;
    case 203:
        if(length == 1)
        {
            tmpbuf[0] = 203;
            tmpbuf[1] = write_tarif_state;
            NBFi_Send(tmpbuf, 2);
        }
        break;
    case 204:
        if((length >= 4)&& (length <= 1 + 3*4)&& !((length - 1)%3))
        {
            for(i = 0; i != (length - 1)/3; i++)
            {
                m200_settings.twotarifs[i].tarif = data[1 + i*3];
                m200_settings.twotarifs[i].hour = data[2 + i*3];
                m200_settings.twotarifs[i].minute = data[3 + i*3];
            }
            m200_settings.twotarifs[i].tarif = END;
            M200_WriteSettings();
        }
        else
        {
           tmpbuf[0] = 204;

           for(i = 0; i != 4; i++)
           {
                if(m200_settings.twotarifs[i].tarif == END) break;
                tmpbuf[i*3 + 1] = m200_settings.twotarifs[i].tarif;
                tmpbuf[i*3 + 2] = m200_settings.twotarifs[i].hour;
                tmpbuf[i*3 + 3] = m200_settings.twotarifs[i].minute;
           }
           NBFi_Send(tmpbuf, 1 + i*3);
        }
        break;
    case 205:
        if((length >= 4)&&(length <= 1 + 3*9)&& !((length - 1)%3))
        {
            for(i = 0; i != (length - 1)/3; i++)
            {
                m200_settings.threetarifs[i].tarif = data[1 + i*3];
                m200_settings.threetarifs[i].hour = data[2 + i*3];
                m200_settings.threetarifs[i].minute = data[3 + i*3];
            }
            m200_settings.threetarifs[i].tarif = END;
            M200_WriteSettings();
        }
        else
        {
           tmpbuf[0] = 205;
           for(i = 0; i != 9; i++)
           {
                if(m200_settings.threetarifs[i].tarif == END) break;
                tmpbuf[i*3 + 1] = m200_settings.threetarifs[i].tarif;
                tmpbuf[i*3 + 2] = m200_settings.threetarifs[i].hour;
                tmpbuf[i*3 + 3] = m200_settings.threetarifs[i].minute;
           }
           NBFi_Send(tmpbuf, 1 + i*3);
        }
        break;
    case 210:
        if(length >= 2)
        {
            m200_comm_number = data[1];
            M200_Send(data[1], &data[2], length - 2);
        }
        break;
    case 211:
         M200_Send_RAW(&data[1], length - 1);
        break;
    case 239:   //on_off fast_dl
        if(length != 2) break;
        switch(data[1])
        {
        case 0:     //set FAST_DL
            NBFi_Config_Set_FastDl(1);
            ScheduleTask(&m200_fastdl_desc, &ResetFastDl, RELATIVE, SECONDS(60*5));
            break;
        case 1:     //reset FAST_DL
            wtimer0_remove(&m200_fastdl_desc);
            ResetFastDl(0);
            break;
        case 5:     //radio test
            ResetFastDl(0);
            wtimer0_remove(&m200_fastdl_desc);
            nbfi.mode = CRX;
            nbfi.heartbeat_interval = 5;
            ScheduleTask(&m200_radiotest_desc, &RadioTest, RELATIVE, SECONDS(60*3));
            NBFi_SendHeartBeats(0);
            break;
        }
        break;
    case 245:       //set time
        if(length >= 5)
        {
            struct  tm  *time_str;
            bigendian_cpy((uint8_t __xdata*)&data[1], (uint8_t __xdata*)&dltime, 4);
            time_str = (struct tm*)localtime(&dltime);
            tmpbuf[0] = dec2bcd(time_str->tm_wday);
            tmpbuf[1] = dec2bcd(time_str->tm_hour);
            tmpbuf[2] = dec2bcd(time_str->tm_min);
            tmpbuf[3] = dec2bcd(time_str->tm_sec);
            tmpbuf[4] = dec2bcd(time_str->tm_mday);
            tmpbuf[5] = dec2bcd(time_str->tm_mon + 1);
            tmpbuf[6] = dec2bcd(time_str->tm_year - 100);
            m200_comm_number = 0x02;
            M200_Send(0x02, tmpbuf, 7);
        }
        else if(length == 1)
        {
            tmpbuf[0] = 245;
            bigendian_cpy((uint8_t __xdata*)&dltime, (uint8_t __xdata*)&tmpbuf[1], 4);
            NBFi_Send(tmpbuf, 5);
        }
        break;
    }
}

uint16_t __xdata h_interval;
uint16_t __xdata SW_IN;
void M200_Loop()
{
    static uint16_t counter = 0;
    if(nbfi.heartbeat_interval > 60) h_interval = nbfi.heartbeat_interval;
    if(!SW_IN)
    {
        sw_free = 0;
        if(++counter == 300)
        {
            counter = 0;
            PA_EN = 0;
            delay_ms(20);
            PA_EN = 1;
            delay_ms(20);
            PA_EN = 0;
//            wtimer0_remove(&m200_radiotest_desc);
            if(CheckTask(&m200_fastdl_desc))
            {
                wtimer0_remove(&m200_fastdl_desc);
                ResetFastDl(0);
            }
            else
            {
                NBFi_Config_Set_FastDl(1);
                ScheduleTask(&m200_fastdl_desc, &ResetFastDl, RELATIVE, SECONDS(60*2));
            }
            //delay_ms(100);
        }
        NBFi_Force_process();
    }
    else
    {
        if(counter && !CheckTask(&m200_fastdl_desc))
        {
            if(regular_state == 0)
            {
                regular_state = 5;
                SendRegular(0);
            }
            nbfi.heartbeat_interval = 2;
            ScheduleTask(&m200_active_desc, &ResetActive, RELATIVE, SECONDS(60*20));
        }
        counter = 0;
        sw_free = 1;
    }


}

void ResetActive(struct wtimer_desc __xdata *desc)
{
    nbfi.heartbeat_interval = h_interval;
}

void ResetFastDl(struct wtimer_desc __xdata *desc)
{
    NBFi_Config_Set_FastDl(0);
    nbfi.heartbeat_interval = 2;
    ScheduleTask(&m200_active_desc, &ResetActive, RELATIVE, SECONDS(60*20));
}
void RadioTest(struct wtimer_desc __xdata *desc)
{
    NBFi_Config_Set_FastDl(1);
    ScheduleTask(&m200_fastdl_desc, &ResetFastDl, RELATIVE, SECONDS(60*2));
}

void M200_Send_Event(uint8_t event, uint32_t time, uint16_t data)
{
    tmpbuf[0] = 0x33;
    tmpbuf[1] = (time >> 24) & 0xFF;
    tmpbuf[2] = (time >> 16) & 0xFF;
    tmpbuf[3] = (time >> 8) & 0xFF;
    tmpbuf[4] = (time >> 0) & 0xFF;
    tmpbuf[5] = event;
    tmpbuf[6] = (data >> 8) & 0xFF;
    tmpbuf[7] = (data >> 0) & 0xFF;
    NBFi_Send(tmpbuf, 8);
}

void M200_Write_Tarif_Packet( TARIF_ZONE * zone, uint8_t dayofweek, uint8_t month)
{
    uint8_t mas[32];

    for(uint8_t i = 0; i != 8; i++)
    {
        if((*zone).tarif != END)
        {

            mas[i*2] = (((uint8_t)((*zone).tarif)) << 6) + dec2bcd((*zone).hour);
            mas[i*2 + 1] = dec2bcd((*zone).minute);
            zone++;
        }
        else
        {
            mas[i*2] = 0xff;
            mas[i*2 + 1] = 0xff;
        }
    }
    mas[16] = (month << 4) + dayofweek;
    M200_Send(0x11, mas, 17);
}
void M200_Write_Tarif_Main(struct wtimer_desc __xdata *desc)
{
    uint8_t data[1];
    switch(write_tarif_state)
    {
    case 0:
        if(regular_state|sinchro_state)
        {
            ScheduleTask(&m200_write_tarif_desc, &M200_Write_Tarif_Main, RELATIVE, SECONDS(10));
            return;
        }
        write_tarif_state = 1;
        write_tarif_try_num = 0;
    case 1:
        data[0] = 0x03;
        if(++write_tarif_try_num <= 3) M200_Send(0x0A, data, 1);
        else
        {
            write_tarif_state = 0;
            m200_settings.t_mode = 0;
            M200_WriteSettings();
            M200_Send_Event(200, 0, 0x0A*256);
            return;
        }
        ScheduleTask(&m200_write_tarif_desc, &M200_Write_Tarif_Main, RELATIVE, SECONDS(1));
        return;
    case 100:
        if(++write_tarif_try_num <= 3) M200_Send(0x2A, data, 0);
        else
        {
            write_tarif_state = 0;
            m200_settings.t_mode = 0;
            M200_WriteSettings();
            M200_Send_Event(200, 0, 0x2A*256);
            return;
        }
        ScheduleTask(&m200_write_tarif_desc, &M200_Write_Tarif_Main, RELATIVE, SECONDS(1));
        return;
    case 101:
        display_mode &= 0xe0;
        switch(m200_settings.t_mode)
        {
        case 1:
            display_mode += 0x10;
            break;
        case 2:
            display_mode += 0x13;
            break;
        case 3:
            display_mode += 0x17;
            break;
        }
        data[0] = display_mode;
        if(++write_tarif_try_num <= 3) M200_Send(0x09, data, 1);
        else
        {
            write_tarif_state = 0;
            m200_settings.t_mode = 0;
            M200_WriteSettings();
            M200_Send_Event(200, 0, 0x09*256);
            return;
        }
        ScheduleTask(&m200_write_tarif_desc, &M200_Write_Tarif_Main, RELATIVE, SECONDS(1));
        return;
    case 98:
        write_tarif_state = 99;
        M200_WriteSettings();
        M200_Send_Event(0x11, 0, 0);
        return;
    case 99:
        write_tarif_state = 0;
        ScheduleTask(&m200_write_tarif_desc, &M200_Write_Tarif_Main, RELATIVE, MILLISECONDS(5));
        return;
    default:

        if(++write_tarif_try_num <= 3)
        {
            M200_Write_Tarif_Packet( tarif_mode, (write_tarif_state - 2)%8, (write_tarif_state - 2)/8);
        }
        else
        {
            write_tarif_state = 0;
            m200_settings.t_mode = 0;
            M200_WriteSettings();
            M200_Send_Event(200, 0, 0x11*256);
            return;
        }
        ScheduleTask(&m200_write_tarif_desc, &M200_Write_Tarif_Main, RELATIVE, SECONDS(1));
        return;
    }
}
